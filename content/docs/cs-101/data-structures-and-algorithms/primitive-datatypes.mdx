---
title: Primitive Data Types & Memory - Deep Dive
description: Most basic data types (built-in) in programming languages.
order: 1
---
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';
import { FolderCardsWithSheets } from "@/components/folder-cards-with-sheets";
import { DynamicSheet } from "@/components/dynamic-sheets";
import { ShortsList } from "@/components/shorts-list";
import { shortsSource } from "@/lib/source";

## 1. Introduction to Primitive Data Types
  #### What are primitive data types ?
      - Most basic built-in types provided by programming languages.
      - Why are they called primitive ? 
        - Because these are Fundamental, Indivisible and not composed of other types.
      - Serve as the building blocks for data manipulation and storage.

  #### Common Primitive Data Types
    | Type | Description | Examples |
    | ---- | ----------- | -------- |
    | Integer (`int`) | Whole numbers without a fractional part. Can be positive, negative, or zero. | `-3`, `0`, `42` |
    | Floating-point (`float`, `double`) | Real numbers that include a fractional part (decimal). Typically implemented with IEEE 754. | `3.14`, `-0.001`, `2.0` |
    | Character (`char`) | A single character (letter, digit, or symbol). | `'A'`, `'b'`, `'3'`, `'#'` |
    | Boolean (`bool`) | Logical type with two possible values: `true` or `false`. Used in conditions and logical operations. | `true`, `false` |
    | String (`str`) | A sequence of characters used for text. In many languages strings are treated as a primitive-like type. | `"hello"`, `"text"` |
    | Null / Nil / None | Denotes the absence of a value or a null reference. Representation differs across languages (`null`, `nil`, `None`). | `null`, `nil`, `None` |

  #### How they differ across languages
    | Type | Description | Examples |
    | ---- | ----------- | -------- |
    | **Size and Range** | Different languages may define different sizes for primitive types. For example, an `int` in C++ might be 4 bytes, while in Java, it is always 4 bytes regardless of the platform. | `int` (C++: 4 bytes, Java: 4 bytes) |
    | **Type Naming**    | The names of primitive types can vary. For instance, what is called `float` in C/C++ is referred to as `double` in some other languages. | `float` (C/C++), `double` (Java) |
    | **Default Values** | Some languages assign default values to uninitialized variables (e.g., `0` for integers), while others may leave them undefined. | `int` (C++: 0), `int` (Java: 0) |

## 2. Understanding Binary Representation
  #### Bits and bytes
  - Bits are the smallest unit of data in a computer memory, represented as either 0 or 1.
  - Bytes are composed of 8 bits and can represent 256 different values (0-255).
  - Each primitive data type is stored in memory using a specific number of bytes.
  - For example:
    - `int` or `float` (4 bytes = 32 bits)
    - `double` (8 bytes = 64 bits)
    - `char` (1 byte = 8 bits)
    - `bool` (1 byte or 1 bit, depending on the language)
  - Least Significant Bit (LSB): The right most bit in the memory representation.
  - Most Significant Bit (MSB): The left most bit in the memory representation.
    - MSB (Most Significant Bit) ← ← ← ← ← ← ← ← LSB (Least Significant Bit)
  
  #### Endianness
  - Defines how bytes are ordered when storing or transmitting multi-byte data (like integers or floating-point numbers).
  - Big-endian: Most significant byte (left most) is stored first.
  - Little-endian: Least significant byte (right most) is stored first.
  <Callout type="info">
    #### Why Endianness matters ?
    - Because it affects how data is read/written across different systems depending on architecture.
    - This directly affects the processing speed and memory usage.
    - Almost all modern general-purpose processors today are little-endian. (x86, x86-64 (Intel, AMD))
    - Some older main-frames (IBM mainframes, some PowerPC, SPARC) use big-endian.
  </Callout>

  - Big-endian survives in networking protocols, mainframes, and legacy embedded systems.

  | Domain                              | Why Big-Endian Persists                                                                        | Example                                              |
  | ----------------------------------- | ---------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
  | **Networking (Internet protocols)** | Standardized as **network byte order = big-endian**                                            | TCP/IP headers, IPv4, IPv6, DNS, HTTP binary headers |
  | **File Formats**                    | Some older standards assumed big-endian byte order                                             | Classic image formats (TIFF), older audio formats    |
  | **Mainframes**                      | IBM systems built decades of infrastructure around it                                          | z/OS, COBOL environments                             |
  | **Embedded Systems**                | Some DSPs (Digital Signal Processors) and network chips use big-endian for hardware simplicity | Routers, switches                                    |
  | **Cross-Platform Serialization**    | Big-endian used for interoperability                                                           | Java `.class` files, some binary protocols           |

  #### Why little-endian won ?
    - **Hardware efficiency**: The LSB stored first simplifies arithmetic operations (increment, carry, overflow).
    - **Backward compatibility**: Intel’s dominance in PCs standardized little-endian in compilers and OSes.
    - **Software ecosystem**: Windows, Linux, macOS (post-Intel), and Android use little-endian memory.
    - **Flexibility**: ARM and RISC-V (modern CPUs) chose little-endian as the default to stay compatible.
    
  - Which is more efficient ? Well, it depends on the use case:
    | Aspect                      | Little-Endian Advantage                                                                                                              | Big-Endian Role                                                                             |
    | --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------- |
    | **Arithmetic Efficiency**   | Incrementing and numerical updates are faster since the least significant byte (LSB) is stored first — simplifying carry operations. | No direct arithmetic advantage.                                                             |
    | **Sequential Processing**   | Ideal for algorithms that update data sequentially (e.g., adding counters or iterating byte arrays).                                 | May need extra rearrangement when processing byte-wise data.                                |
    | **Data Structures**         | Simplifies pointer-heavy structures like linked lists — where address or “next” often relies on the least significant bytes.         | Typically used in high-level, cross-platform communication rather than memory optimization. |
    | **Network & Serialization** | May require conversion before transmission.                                                                                          | Preferred for standardized data exchange between systems.                                   |
  
  - Example: The hexadecimal number `0x12345678` would be stored as:
    - Big-endian: `12 34 56 78`
    - Little-endian: `78 56 34 12`

## 3. Binary number system in memory
  - Uses only two digits: 0 and 1. 
    - Why ? A capacitor can be either charged (1) or uncharged (0), making binary ideal for electronic circuits.
    - Each time we want to represent a number in memory, we convert it to binary because computers operate using electrical signals that can be easily represented as two states (on/off).
    - Memory or RAM and processor stores data in binary form for efficient processing and retrieval.
  - Each bit represents a power of 2, starting from 2^0 on the right.
  
  - For example, consider Integer Number +25 in 8-bit
    | Decimal | Binary | Explanation |
    | ------- | ------ | ----------- |
    | +25 | `00011001` | Normal binary of 25 (+25)    |
    | -25 | `11100111` | Two's complement of 25 (-25) |
    
    Each bit doubles in weight from right to left:  
      `2⁷ 2⁶ 2⁵ 2⁴ 2³ 2² 2¹ 2⁰`  
    → `0 0 0 1 1 0 0 1`  
    → `16 + 8 + 1 = 25`
  
  - Signed and Unsigned binary representation
    - Unsigned: Only non-negative values (0 and positive).
    - Signed: Can represent both positive and negative values.

  #### How can memory represent negative numbers?  
  - Signed magnitude: The value is stored in the remaining bits, with the sign bit indicating positive or negative.
    - Sign bit: The leftmost bit indicates the sign (0 for positive, 1 for negative).
    - Why only left most bit? Because it allows for a straightforward representation of both positive and negative values.

  - One's complement: Inverts all bits (0s to 1s and 1s to 0s) to represent negative numbers.
    - Why ? Because it simplifies the binary subtraction process.
    - However, it has two representations for zero (+0 and -0), which can complicate arithmetic operations.
    
  - Two's complement (most common): Inverts all bits and add 1 to the least significant bit (LSB).
    - Why ? Because it allows for easy addition and subtraction of binary numbers, including negative values.
    - Why its called 2's complement ?
      - Because it is derived by taking the complement (inverting the bits) of the number and adding one to the least significant bit (LSB).
    - Why its preferred ? 
      - Because it eliminates the issue of having two representations for zero (positive and negative zero) and simplifies arithmetic operations.

  #### How to calculate 2’s Complement

    | Step | Action | Result |
    | ---- | ------ | ------ |
    | 1️⃣ | Write +25 binary | `00011001` |
    | 2️⃣ | Invert bits | `11100110` |
    | 3️⃣ | Add 1 | `11100111` ✅ |

    So,  **-25** = `11100111` in 8-bit two’s complement form.

    #### Visualization of 2's Complement
    ```text
    Bit position: | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    ------------------------------------------------
    +25 binary:   | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 1 |
    -25 binary:   | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 |
                    ↑
                  MSB Sign bit 
                  (1 indicates negative)
                  (0 indicates positive)       
    ```

  #### Range of integers
    | type | Size | Range |
    | ---- | ---- | ----- |
    | int | 2 bytes (16 bits) | -32,768 to 32,767 |
    | signed int | 2 bytes (16 bits) | -32,768 to 32,767 |
    | unsigned int | 2 bytes (16 bits) | 0 to 65,535 |
    | long int | 4 bytes (32 bits) | -2,147,483,648 to 2,147,483,647 |
    | long | 4 bytes (32 bits) | -2,147,483,648 to 2,147,483,647 |
    | unsigned long | 4 bytes (32 bits) | 0 to 4,294,967,295 |
    | long long | 8 bytes (64 bits) | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |
    | unsigned long long | 8 bytes (64 bits) | 0 to 18,446,744,073,709,551,615 | 
    | float | 4 bytes (32 bits) | Approx. ±1.5 x 10^-45 to ±3.4 x 10^38 |
    | double | 8 bytes (64 bits) | Approx. ±5.0 x 10^-324 to ±1.7 x 10^308 |
    | char | 1 byte (8 bits) | 0 to 255 (ASCII) or -128 to 127 (signed) |
    | unsigned char | 1 byte (8 bits) | 0 to 255 |
    
  #### How can memory represent real numbers ?
    - Why integers aren't enough ? 
      - Integers can only represent whole numbers, but many applications require fractional values (e.g., 3.14, -0.001).
    - Floating-point representation allows for a wide range of real numbers, including very small and very large values.
    - The IEEE 754 standard is commonly used for representing floating-point numbers in memory.
    
  #### IEEE 754 Format
    - It usually has 2 main formats: Single Precision (32-bit) and Double Precision (64-bit) with each one having 3 parts: Sign, Exponent, and Mantissa.
    ```text title="IEEE 754 Format - 32 bit"
    | Part                    | Meaning                           | Bits |
    | ----------------------- | --------------------------------- | ---- |
    | **Sign**                | 0 = positive, 1 = negative        | 1    |
    | **Exponent**            | Power of 2, with a bias of 127    | 8    |
    | **Mantissa (Fraction)** | Decimal part (significant digits) | 23   |
    ```

    - For example, the number 3.14 would be represented in IEEE 754 as follows
    
    | Field        | Bits                      | Meaning              |
    | ------------ | ------------------------- | -------------------- |
    | **Sign**     | `0`                       | Positive number      |
    | **Exponent** | `10000000`                | (128 = 127 + 1 bias) |
    | **Mantissa** | `10010001111010111000011` | Fractional part      |

    - Combining these parts gives the full 32-bit representation of 3.14 in IEEE 754 format.

    | Sign (1)  | Exponent (8)  |        Mantissa (23 bits)         |
    | --------- | ------------- | --------------------------------- |
    | 0         | 10000000      | 10010001111010111000011           |

  #### Double precision (64-bit) overview
    - Similar structure but with more bits for exponent and mantissa, allowing for greater precision and range.
    - Often used in scientific computations and applications requiring high precision such as banking and finance.
    ```text title="IEEE 754 Format - 64 bit"
    | Part                    | Meaning                           | Bits |
    | ----------------------- | --------------------------------- | ---- |
    | **Sign**                | 0 = positive, 1 = negative        | 1    |
    | **Exponent**            | Power of 2, with a bias of 1023   | 11   |
    | **Mantissa (Fraction)** | Decimal part (significant digits) | 52   |
    ```

  #### Summary of Binary Representations
    | Type              | Decimal | Binary Representation                | Memory Breakdown       |
    | ----------------- | ------- | ------------------------------------ | ---------------------- |
    | **Integer (+25)** | `25`    | `00011001`                           | 8 bits straight binary |
    | **Integer (-25)** | `-25`   | `11100111`                           | Two’s complement       |
    | **Float (3.14)**  | `3.14`  | `0 10000000 10010001111010111000011` | IEEE 754               |

  ```text title="Visual Comparison of Integer and Float Representation"
               ┌─────────────────────────────┬──────────────────────────────┐
               │         INTEGER (8-bit)     │       FLOAT (IEEE 754)       │
               ├───────────────┬─────────────┼─────────────┬────────────────┤
    Bits:      │ 0 0 0 1 1 0 0 1 │ (25)      │ 0 | 10000000 | 100100011     │
    Meaning:   │ Sign + Value                │ Sign | Exponent | Mantissa   │
    Precision: │ Exact                       │ Approximate (Binary Fraction)│
               └─────────────────────────────┴──────────────────────────────┘
  ```

  #### Common pitfalls in programming
    - Precision errors with floating-point arithmetic.
      - Rounding errors and representation limitations.
      - Loss of precision in large calculations.
      - Inconsistent results across different hardware or compilers.
    - Overflow and underflow issues with integers.
      - Values exceeding the maximum or minimum representable range.
      - Unexpected behavior when crossing these limits.
    - Misinterpretation of signed vs unsigned types.
      - Confusion leading to bugs or security vulnerabilities.
      - Incorrect assumptions about value ranges.
      - Implicit type conversions causing unexpected results.

    - How to resolve these ?
      - Use appropriate data types based on application needs.
      - Implement proper error handling for arithmetic operations.
      - Be aware of language-specific behaviors and standards.
      - Test thoroughly across different platforms and scenarios.
      - Consider using libraries for high-precision arithmetic when necessary.
      - Avoid mixing signed and unsigned types in calculations.
      - Use static analysis tools to catch potential issues early in the development process.
      - Document assumptions and limitations regarding data types in the codebase.
      - Java example of using BigDecimal for precise decimal arithmetic in financial applications.
  
  #### Example of using BigDecimal in Java
    ```java
    import java.math.BigDecimal;  
    public class FinancialCalculation {
        public static void main(String[] args) {
            BigDecimal amount1 = new BigDecimal("0.1");
            BigDecimal amount2 = new BigDecimal("0.2");
            BigDecimal total = amount1.add(amount2);
            log.info("Total: " + total); // Outputs: Total: 0.3
        }
    }
    ```

## 4. Characters and Strings in Memory
  - How characters and string having textual data are represented in memory ?
    - Since, computers understand only 0 and 1, we map the characters to a pre-defined set of fixed values accepted globally.
      - There are two main standards for character encoding: ASCII and Unicode.
    - Strings are sequences of characters stored as arrays of these binary values.
    - Different programming languages may use different methods to represent strings in memory, such as null-terminated strings in C or length-prefixed strings in Java and Python.
    
  #### ASCII (American Standard Code for Information Interchange) format
    - ASCII: 7-bit character set (0-127) that defines 128 characters
      - 95 printable characters (letters, digits, punctuation, symbols)
      - 33 non-printable control characters (e.g., newline, carriage return) 
      - Codes 0 to 31 and 127 -> 33 non-printable characters (e.g., newline, carriage return) 
      - Codes 32 t o 126 -> 95 printable characters (letters, digits, punctuation, symbols)
        - Space (code 32)
        - Digits (0–9, codes 48–57) 
        - Uppercase English letters (A–Z, codes 65–90) 
        - Lowercase English letters (a–z, codes 97–122) 
        - Various punctuation and symbols (!, @, #, etc.)
      - Standard ASCII is often stored in an 8-bit byte, with the most significant bit set to 0. 

  #### Unicode format
    - If there is ASCII already, then why another format ?
      - purpose: To represent all characters from every language, symbol, and emoji — in one standard.
      - Character set: over 143000 and growing
      - Each character has a unique code point, e.g., U+0041 → 'A', U+0905 → 'अ'.
      - This by default not an encoding itself -> Unicode defines which characters exist; UTF encodings define how they are stored in bytes.
    - Wont this cause compatibility issues with ASCII encoded systems ?
      - No, all ASCII character set is a subset of unicode by default.
      - 100% compatible — any ASCII file is also valid UTF-8.
      - UTF-8 is the most widely used encoding today (HTML, JSON, Linux, web APIs) due to compatibility and efficiency.

      | Encoding   | Description                                                                         | Byte Usage   | Example                          |
      | ---------- | ----------------------------------------------------------------------------------- | ------------ | -------------------------------- |
      | **UTF-8**  | Variable-length encoding (1–4 bytes per character). Backward compatible with ASCII. | 1–4 bytes    | `'A'` → `41`, `'€'` → `E2 82 AC` |
      | **UTF-16** | Uses 2 or 4 bytes per character. Efficient for Asian scripts.                       | 2 or 4 bytes | `'A'` → `00 41`, `'€'` → `20 AC` |
      | **UTF-32** | Fixed-length encoding (4 bytes per character). Simplest but memory-heavy.           | 4 bytes      | `'A'` → `00 00 00 41`            |
  
  #### String representation
    - A string is a sequence of characters stored contiguously in memory.
    - Each character is typically encoded using ASCII or Unicode (UTF-8 / UTF-16).
    - Example: "Hi" → ['H', 'i'] → [72, 105] in ASCII.

    | Concept       | Example (C-style)          | Notes                                 |
    | ------------- | -------------------------- | ------------------------------------- |
    | Memory Layout | `['H', 'i']`               | Stored as an array of character bytes |
    | Access        | `str[0] → 'H'`             | Constant-time access                  |
    | Mutability    | Mutable in C (char arrays) | Immutable in Java/Python              |

    - Null-terminated strings (Common in C and C++).
      - A special null character ('\0' or 0x00) marks the end of the string.
      - Length is determined by scanning memory until '\0' is found.
      - Example	Representation in Memory	Comment
        - "Hi"	['H', 'i', '\0']	3 bytes (includes terminator)
        - "Hello"	['H', 'e', 'l', 'l', 'o', '\0']	Must manually manage \0

      <Callout type="warn">
        Forgetting the null terminator in C can cause buffer overruns or garbage reads.
      </Callout>
      
    - Length-prefixed strings
      - Used in Java, Python, and many modern runtimes.
      - The length is stored separately (as an integer) before the string’s characters.
      - Prevents scanning overhead — faster to get length.

      | Language | Stored As                          | Access                                      | Example Representation |
      | -------- | ---------------------------------- | ------------------------------------------- | ---------------------- |
      | Java     | `[length=5][‘H’,‘e’,‘l’,‘l’,‘o’]`  | O(1) access to length                       | Stored in heap         |
      | Python   | `[len][encoding info][characters]` | Internal optimization via `PyUnicodeObject` | Supports Unicode       |
  
  #### Null terminator (\0) in C vs length property in Java/Python

    | Aspect           | C / C++                                | Java / Python                     |
    | ---------------- | -------------------------------------- | --------------------------------- |
    | End of String    | Marked by `'\0'` byte                  | Managed by stored length          |
    | Length Retrieval | Requires traversal (O(n))              | Constant time (O(1))              |
    | Risk             | Buffer overflows, unterminated strings | None — runtime-managed            |
    | Memory           | Slightly smaller (no length integer)   | Slightly larger (stores metadata) |
    | Performance      | Slower for repeated length checks      | Faster access, Unicode-safe       |

  
    <Callout type="info">
      C prioritizes simplicity and control, while Java/Python prioritize safety and speed.
    </Callout>

  #### UTF-8 / UTF-16 encoding differences

    | Feature                 | **UTF-8**                   | **UTF-16**                     |
    | ----------------------- | --------------------------- | ------------------------------ |
    | **Encoding Type**       | Variable-length (1–4 bytes) | Variable-length (2 or 4 bytes) |
    | **ASCII Compatibility** | ✅ Fully compatible          | ❌ Not compatible              |
    | **Common Usage**        | Web, Linux, JSON, HTML      | Java, Windows, Android         |
    | **Memory Efficiency**   | Efficient for English text  | Efficient for Asian scripts    |
    | **Example (‘A’)**       | `0x41` (1 byte)             | `0x00 41` (2 bytes)            |
    | **Example (‘€’)**       | `E2 82 AC` (3 bytes)        | `20 AC` (2 bytes)              |
    | **Example (‘中’)**       | `E4 B8 AD` (3 bytes)        | `4E 2D` (2 bytes)             |

## 5. Boolean and Null Types in Memory
  #### Boolean representation (1 bit, true/false)
    - Represented as 1 bit logically but often stored as 1 byte (8 bits) for alignment.
    - Common mappings:
      - false → 0x00
      - true → 0x01

    | Language | Representation                    | Notes                               |
    | -------- | --------------------------------- | ----------------------------------- |
    | C / C++  | 1 byte (`0` / `1`)                | `bool` or `_Bool` type              |
    | Java     | 1 byte (JVM optimized internally) | Stored as `int` in arrays sometimes |
    | Python   | Objects: `True` and `False`       | References to singletons            |

    <Callout type="info">
      CPUs handle bytes better than bits, so booleans occupy 1 byte typically.
    </Callout>

  #### Null representation (null pointer, special value)
    - Null, None, nil — what “nothing” means in memory ?
    
    | Concept               | Meaning                                                                  | Representation                           |
    | --------------------- | ------------------------------------------------------------------------ | ---------------------------------------- |
    | **Null Pointer**      | Variable that points to “nothing”                                        | Address = `0x0`                          |
    | **Special Value**     | Placeholder indicating no valid data                                     | e.g. `-1`, `NaN`, or `None`              |
    | **Language Examples** | `null` (Java, JS), `None` (Python), `nullptr` (C++11), `nil` (Go, Swift) | All mean *no object / invalid reference* |

    <Callout type="warn">
      Accessing or dereferencing a null pointer causes segmentation fault / NullPointerException.
    </Callout>
    
  #### Language-specific variations

    | Language   | Null Keyword           | Stored As                | Notes                                         |
    | ---------- | ---------------------- | ------------------------ | --------------------------------------------- |
    | C / C++    | `NULL` / `nullptr`     | Address `0x0`            | Pointer with no target                        |
    | Java       | `null`                 | Reference = 0            | Throws `NullPointerException` if dereferenced |
    | Python     | `None`                 | Singleton object         | Safe — cannot cause segmentation fault        |
    | JavaScript | `null` and `undefined` | Special primitive values | Type quirks (`typeof null → object`)          |


## 6. Composite and Object Representation (Bridge Section)
  #### What happens when you store an object?
    - The variable stores a reference (pointer) to a memory location.
    - The object’s data resides in heap memory.
    - Accessing a field means dereferencing the pointer to that memory block.

  #### Memory layout of objects

  ```text title="Typical Java Object"
    | Component               | Description                                           |
    | ----------------------- | ----------------------------------------------------- |
    | **Header / Metadata**   | Info like class type, GC flags, synchronization bits. |
    | **Field Data**          | Actual variables/attributes of the object.            |
    | **Padding / Alignment** | Ensures efficient memory access by CPU.               |

    [Header | Field1 | Field2 | Padding]
  ```
  
  #### Pointers and references
    | Concept           | Description                                         |
    | ----------------- | --------------------------------------------------- |
    | **Pointer**       | Holds a *memory address* directly (C/C++).          |
    | **Reference**     | Abstract handle to an object (Java, Python).        |
    | **Dereferencing** | Accessing the data the pointer/reference points to. |

  #### Stack vs Heap memory allocation
    | Feature          | **Stack**                               | **Heap**                                            |
    | ---------------- | --------------------------------------- | --------------------------------------------------- |
    | **Purpose**      | Stores function frames, local variables | Stores dynamically allocated data (objects, arrays) |
    | **Managed By**   | Compiler (automatic)                    | Programmer / Garbage Collector                      |
    | **Lifetime**     | Ends when function returns              | Persists until freed or GC’d                        |
    | **Access Speed** | Very fast                               | Slower                                              |
    | **Example**      | `int x = 5;`                            | `new int[10];`, `new Object()`                      |

    <Callout type="info">
    In short, usage depends on the use case.
      - Stack = Temporary, Fast, Small 
      - Heap = Persistent, Slower, Larger
    </Callout>

  #### Object headers and metadata (at a high level)
    | Runtime      | Object Header Contains                       | Example                     |
    | ------------ | -------------------------------------------- | --------------------------- |
    | **Java JVM** | Class pointer, hash code, GC info, lock bits | ~12–16 bytes per object     |
    | **Python**   | Reference count, type pointer, size          | Stored in `PyObject_HEAD`   |
    | **.NET CLR** | Type handle, sync block index                | Managed by runtime metadata |


